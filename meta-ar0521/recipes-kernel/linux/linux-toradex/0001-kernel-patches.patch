diff --git a/drivers/media/platform/mxc/capture/mx6s_capture.c b/drivers/media/platform/mxc/capture/mx6s_capture.c
index 84f0e40e49e0..994898edde5c 100644
--- a/drivers/media/platform/mxc/capture/mx6s_capture.c
+++ b/drivers/media/platform/mxc/capture/mx6s_capture.c
@@ -50,7 +50,7 @@
 #define MX6S_CAM_VERSION "0.0.1"
 #define MX6S_CAM_DRIVER_DESCRIPTION "i.MX6S_CSI"
 
-#define MAX_VIDEO_MEM 64
+#define MAX_VIDEO_MEM 160
 
 /* reset values */
 #define CSICR1_RESET_VAL	0x40000800
@@ -340,6 +340,7 @@ struct mx6s_csi_dev {
 
 	bool csi_mipi_mode;
 	bool csi_two_8bit_sensor_mode;
+	bool cam_csi_bridge;
 	const struct mx6s_csi_soc *soc;
 	struct mx6s_csi_mux csi_mux;
 };
@@ -865,7 +866,20 @@ static int mx6s_configure_csi(struct mx6s_csi_dev *csi_dev)
 
 		switch (csi_dev->fmt->pixelformat) {
 		case V4L2_PIX_FMT_UYVY:
+			if (csi_dev->cam_csi_bridge)
+			{
+				cr18 &= ~BIT_MIPI_DOUBLE_CMPNT;
+				cr18 &= ~BIT_MIPI_YU_SWAP;
+			}
+			cr18 |= BIT_MIPI_DATA_FORMAT_YUV422_8B;
+			break;
 		case V4L2_PIX_FMT_YUYV:
+			if (csi_dev->cam_csi_bridge)
+			{
+				cr18 |= BIT_MIPI_DOUBLE_CMPNT;
+
+				cr18 |= BIT_MIPI_YU_SWAP;
+			}
 			cr18 |= BIT_MIPI_DATA_FORMAT_YUV422_8B;
 			break;
 		case V4L2_PIX_FMT_SBGGR8:
@@ -1132,7 +1146,7 @@ static irqreturn_t mx6s_csi_irq_handler(int irq, void *data)
 		csi_write(csi_dev, cr18, CSI_CSICR18);
 
 		csi_dev->skipframe++;
-		pr_debug("base address switching Change Err.\n");
+		pr_info("base address switching Change Err.\n");
 	}
 
 	if ((status & BIT_DMA_TSF_DONE_FB1) &&
@@ -1269,6 +1283,9 @@ static struct v4l2_file_operations mx6s_csi_fops = {
 static int mx6s_vidioc_enum_input(struct file *file, void *priv,
 				 struct v4l2_input *inp)
 {
+	struct mx6s_csi_dev *csi_dev = video_drvdata(file);
+	struct v4l2_subdev *sd = csi_dev->sd;
+
 	if (inp->index != 0)
 		return -EINVAL;
 
@@ -1276,6 +1293,10 @@ static int mx6s_vidioc_enum_input(struct file *file, void *priv,
 	inp->type = V4L2_INPUT_TYPE_CAMERA;
 	strcpy(inp->name, "Camera");
 
+	if (csi_dev->cam_csi_bridge){
+		if (!v4l2_subdev_has_op(sd, video, s_std))
+			inp->capabilities &= ~V4L2_IN_CAP_STD;
+	}
 	return 0;
 }
 
@@ -1476,9 +1497,38 @@ static int mx6s_vidioc_g_fmt_vid_cap(struct file *file, void *priv,
 				    struct v4l2_format *f)
 {
 	struct mx6s_csi_dev *csi_dev = video_drvdata(file);
+	struct v4l2_subdev *sd = csi_dev->sd;
+	struct v4l2_subdev_format format = {
+		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+	};
+	int ret;
 
 	WARN_ON(priv != file->private_data);
 
+	if (csi_dev->cam_csi_bridge){
+	/*
+	 * Get the format information from the subdev
+	 */
+		ret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &format);
+		if (ret) {
+			pr_info("Error in getting format. ret = %d\n", ret);
+			return ret;
+		}
+		else {
+			struct v4l2_pix_format *pix = &csi_dev->pix;
+			struct mx6s_fmt *fmt;
+
+			v4l2_fill_pix_format(pix, &format.format);
+			if (pix->field != V4L2_FIELD_INTERLACED)
+				pix->field = V4L2_FIELD_NONE;
+
+			fmt = format_by_mbus(format.format.code);
+			pix->pixelformat = fmt->pixelformat;
+			pix->sizeimage = fmt->bpp * pix->height * pix->width;
+			pix->bytesperline = fmt->bpp * pix->width;
+		}
+	}
+
 	f->fmt.pix = csi_dev->pix;
 
 	return 0;
@@ -1623,6 +1673,10 @@ static int mx6s_vidioc_enum_framesizes(struct file *file, void *priv,
 	int ret;
 
 	fmt = format_by_fourcc(fsize->pixel_format);
+
+	if(fmt == NULL)
+		return -EINVAL;
+	
 	if (fmt->pixelformat != fsize->pixel_format)
 		return -EINVAL;
 	fse.code = fmt->mbus_code;
@@ -1665,6 +1719,10 @@ static int mx6s_vidioc_enum_frameintervals(struct file *file, void *priv,
 	int ret;
 
 	fmt = format_by_fourcc(interval->pixel_format);
+
+	if(fmt == NULL)
+		return -EINVAL;
+	
 	if (fmt->pixelformat != interval->pixel_format)
 		return -EINVAL;
 	fie.code = fmt->mbus_code;
@@ -1677,6 +1735,99 @@ static int mx6s_vidioc_enum_frameintervals(struct file *file, void *priv,
 	return 0;
 }
 
+#ifdef CONFIG_VIDEO_ECAM
+static int mx6s_vidioc_queryctrl(struct file *file, void *priv,
+                             struct v4l2_queryctrl *a)
+{
+        struct mx6s_csi_dev *csi_dev = video_drvdata(file);
+        struct v4l2_subdev *sd = csi_dev->sd;
+        return v4l2_subdev_call(sd, core, queryctrl, a);
+}
+
+static int mx6s_vidioc_query_ext_ctrl(struct file *file, void *priv,
+                             struct v4l2_query_ext_ctrl *qec)
+{
+        struct v4l2_queryctrl qc = {
+                .id = qec->id
+        };
+        int ret;
+
+	ret = mx6s_vidioc_queryctrl(file, priv, &qc);
+
+        if (ret)
+                return ret;
+	
+        qec->id = qc.id;
+        qec->type = qc.type;
+        strlcpy(qec->name, qc.name, sizeof(qec->name));
+        qec->maximum = qc.maximum;
+        qec->minimum = qc.minimum;
+        qec->step = qc.step;
+        qec->default_value = qc.default_value;
+        qec->flags = qc.flags;
+        qec->elem_size = 4;
+        qec->elems = 1;
+        qec->nr_of_dims = 0;
+        memset(qec->dims, 0, sizeof(qec->dims));
+        memset(qec->reserved, 0, sizeof(qec->reserved));
+
+        return 0;
+}
+
+static int mx6s_vidioc_querymenu(struct file *file, void *priv,
+                             struct v4l2_querymenu *a)
+{
+        struct mx6s_csi_dev *csi_dev = video_drvdata(file);
+        struct v4l2_subdev *sd = csi_dev->sd;
+
+        return v4l2_subdev_call(sd, core, querymenu, a);
+}
+
+static int mx6s_vidioc_g_ctrl(struct file *file, void *priv,
+                             struct v4l2_control *a)
+{
+        struct mx6s_csi_dev *csi_dev = video_drvdata(file);
+        struct v4l2_subdev *sd = csi_dev->sd;
+
+        return v4l2_subdev_call(sd, core, g_ctrl, a);
+}
+
+static int mx6s_vidioc_s_ctrl(struct file *file, void *priv,
+                             struct v4l2_control *a)
+{
+        struct mx6s_csi_dev *csi_dev = video_drvdata(file);
+        struct v4l2_subdev *sd = csi_dev->sd;
+
+        return v4l2_subdev_call(sd, core, s_ctrl, a);
+}
+static int mx6s_vidioc_g_ext_ctrls(struct file *file, void *priv,
+                             struct v4l2_ext_controls *a)
+{
+        struct mx6s_csi_dev *csi_dev = video_drvdata(file);
+        struct v4l2_subdev *sd = csi_dev->sd;
+
+        return v4l2_subdev_call(sd, core, g_ext_ctrls, a);
+}
+
+static int mx6s_vidioc_s_ext_ctrls(struct file *file, void *priv,
+                             struct v4l2_ext_controls *a)
+{
+        struct mx6s_csi_dev *csi_dev = video_drvdata(file);
+        struct v4l2_subdev *sd = csi_dev->sd;
+
+        return v4l2_subdev_call(sd, core, s_ext_ctrls, a);
+}
+
+static int mx6s_vidioc_try_ext_ctrls(struct file *file, void *priv,
+                             struct v4l2_ext_controls *a)
+{
+        struct mx6s_csi_dev *csi_dev = video_drvdata(file);
+        struct v4l2_subdev *sd = csi_dev->sd;
+
+        return v4l2_subdev_call(sd, core, try_ext_ctrls, a);
+}
+#endif
+
 static const struct v4l2_ioctl_ops mx6s_csi_ioctl_ops = {
 	.vidioc_querycap          = mx6s_vidioc_querycap,
 	.vidioc_enum_fmt_vid_cap  = mx6s_vidioc_enum_fmt_vid_cap,
@@ -1703,6 +1854,16 @@ static const struct v4l2_ioctl_ops mx6s_csi_ioctl_ops = {
 	.vidioc_s_parm        = mx6s_vidioc_s_parm,
 	.vidioc_enum_framesizes = mx6s_vidioc_enum_framesizes,
 	.vidioc_enum_frameintervals = mx6s_vidioc_enum_frameintervals,
+#ifdef CONFIG_VIDEO_ECAM
+        .vidioc_queryctrl       = mx6s_vidioc_queryctrl,
+        .vidioc_query_ext_ctrl  = mx6s_vidioc_query_ext_ctrl,
+        .vidioc_querymenu       = mx6s_vidioc_querymenu,
+       .vidioc_g_ctrl          = mx6s_vidioc_g_ctrl,
+        .vidioc_s_ctrl          = mx6s_vidioc_s_ctrl,
+        .vidioc_g_ext_ctrls     = mx6s_vidioc_g_ext_ctrls,
+        .vidioc_s_ext_ctrls     = mx6s_vidioc_s_ext_ctrls,
+        .vidioc_try_ext_ctrls   = mx6s_vidioc_try_ext_ctrls
+#endif
 };
 
 static int subdev_notifier_bound(struct v4l2_async_notifier *notifier,
@@ -1891,6 +2052,12 @@ static int mx6s_csi_probe(struct platform_device *pdev)
 	mx6s_csi_mode_sel(csi_dev);
 	mx6s_csi_two_8bit_sensor_mode_sel(csi_dev);
 
+	/*
+	* Add a flag to identify the cam device tree
+	*/
+	csi_dev->cam_csi_bridge =
+		of_property_read_bool(csi_dev->dev->of_node, "cam-csi-bridge");
+
 	of_id = of_match_node(mx6s_csi_dt_ids, csi_dev->dev->of_node);
 	if (!of_id)
 		return -EINVAL;
diff --git a/drivers/media/platform/mxc/capture/mxc_mipi_csi.c b/drivers/media/platform/mxc/capture/mxc_mipi_csi.c
index 636564a8a66b..9f793b677718 100644
--- a/drivers/media/platform/mxc/capture/mxc_mipi_csi.c
+++ b/drivers/media/platform/mxc/capture/mxc_mipi_csi.c
@@ -271,6 +271,7 @@ struct csi_state {
 	struct clk *disp_apb;
 	int irq;
 	u32 flags;
+	bool cam_format_change;
 
 	u32 clk_frequency;
 	u32 hs_settle;
@@ -317,6 +318,10 @@ static const struct csis_pix_format mipi_csis_formats[] = {
 		.code = MEDIA_BUS_FMT_VYUY8_2X8,
 		.fmt_reg = MIPI_CSIS_ISPCFG_FMT_YCBCR422_8BIT,
 		.data_alignment = 16,
+	}, {
+                .code = MEDIA_BUS_FMT_UYVY8_2X8,
+                .fmt_reg = MIPI_CSIS_ISPCFG_FMT_YCBCR422_8BIT,
+                .data_alignment = 16,
 	}, {
 		.code = MEDIA_BUS_FMT_SBGGR8_1X8,
 		.fmt_reg = MIPI_CSIS_ISPCFG_FMT_RAW8,
@@ -508,6 +513,8 @@ static void mipi_csis_set_params(struct csi_state *state)
 		val |= MIPI_CSIS_ISPCFG_ALIGN_32BIT;
 	else /* Normal output */
 		val &= ~MIPI_CSIS_ISPCFG_ALIGN_32BIT;
+	if (state->cam_format_change)
+		val |= 1 << 12; /*Dual Pixel Mode */
 	mipi_csis_write(state, MIPI_CSIS_ISPCONFIG_CH0, val);
 
 	val = (0 << MIPI_CSIS_ISPSYNC_HSYNC_LINTV_OFFSET) |
@@ -667,13 +674,16 @@ static int mipi_csis_s_power(struct v4l2_subdev *mipi_sd, int on)
 {
 	struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
 	struct device *dev = &state->pdev->dev;
+	int ret = 0;
 
-	v4l2_subdev_call(state->sensor_sd, core, s_power, on);
-
+	ret = v4l2_subdev_call(state->sensor_sd, core, s_power, on);
+#if 0
 	if (on)
 		return pm_runtime_get_sync(dev);
 
 	return pm_runtime_put_sync(dev);
+#endif
+	return ret;
 }
 
 static int mipi_csis_s_stream(struct v4l2_subdev *mipi_sd, int enable)
@@ -840,6 +850,65 @@ static int mipi_csis_enum_frameintervals(struct v4l2_subdev *mipi_sd,
 	return v4l2_subdev_call(sensor_sd, pad, enum_frame_interval, NULL, fie);
 }
 
+#ifdef CONFIG_VIDEO_ECAM
+
+static int mipi_csis_queryctrl(struct v4l2_subdev *mipi_sd, struct v4l2_queryctrl *qc)
+{
+        struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+        struct v4l2_subdev *sensor_sd = state->sensor_sd;
+
+	return v4l2_subdev_call(sensor_sd, core, queryctrl, qc);
+}
+
+static int mipi_csis_g_ctrl(struct v4l2_subdev *mipi_sd, struct v4l2_control *ctrl)
+{
+        struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+       struct v4l2_subdev *sensor_sd = state->sensor_sd;
+
+        return v4l2_subdev_call(sensor_sd, core, g_ctrl, ctrl);
+}
+
+static int mipi_csis_s_ctrl(struct v4l2_subdev *mipi_sd, struct v4l2_control *ctrl)
+{
+        struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+        struct v4l2_subdev *sensor_sd = state->sensor_sd;
+
+        return v4l2_subdev_call(sensor_sd, core, s_ctrl, ctrl);
+}
+
+static int mipi_csis_g_ext_ctrls(struct v4l2_subdev *mipi_sd, struct v4l2_ext_controls *ctrls)
+{
+        struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+        struct v4l2_subdev *sensor_sd = state->sensor_sd;
+
+        return v4l2_subdev_call(sensor_sd, core, g_ext_ctrls, ctrls);
+}
+
+static int mipi_csis_s_ext_ctrls(struct v4l2_subdev *mipi_sd, struct v4l2_ext_controls *ctrls)
+{
+        struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+        struct v4l2_subdev *sensor_sd = state->sensor_sd;
+
+        return v4l2_subdev_call(sensor_sd, core, s_ext_ctrls, ctrls);
+}
+
+static int mipi_csis_try_ext_ctrls(struct v4l2_subdev *mipi_sd, struct v4l2_ext_controls *ctrls)
+{
+        struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+       struct v4l2_subdev *sensor_sd = state->sensor_sd;
+
+        return v4l2_subdev_call(sensor_sd, core, try_ext_ctrls, ctrls);
+}
+
+static int mipi_csis_querymenu(struct v4l2_subdev *mipi_sd, struct v4l2_querymenu *qm)
+{
+        struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+        struct v4l2_subdev *sensor_sd = state->sensor_sd;
+
+        return v4l2_subdev_call(sensor_sd, core, querymenu, qm);
+}
+#endif
+
 static int mipi_csis_log_status(struct v4l2_subdev *mipi_sd)
 {
 	struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
@@ -855,6 +924,15 @@ static int mipi_csis_log_status(struct v4l2_subdev *mipi_sd)
 static struct v4l2_subdev_core_ops mipi_csis_core_ops = {
 	.s_power = mipi_csis_s_power,
 	.log_status = mipi_csis_log_status,
+#ifdef CONFIG_VIDEO_ECAM
+	.queryctrl = mipi_csis_queryctrl,
+        .g_ctrl = mipi_csis_g_ctrl,
+       .s_ctrl = mipi_csis_s_ctrl,
+        .g_ext_ctrls = mipi_csis_g_ext_ctrls,
+        .s_ext_ctrls = mipi_csis_s_ext_ctrls,
+        .try_ext_ctrls = mipi_csis_try_ext_ctrls,
+        .querymenu = mipi_csis_querymenu,
+#endif
 };
 
 static struct v4l2_subdev_video_ops mipi_csis_video_ops = {
@@ -965,6 +1043,7 @@ static int mipi_csis_parse_dt(struct platform_device *pdev,
 	}
 
 	/* Get MIPI CSI-2 bus configration from the endpoint node. */
+	state->cam_format_change = of_property_read_bool(node, "cam-format-change");
 	of_property_read_u32(node, "csis-hs-settle",
 					&state->hs_settle);
 
@@ -1167,7 +1246,8 @@ static int mipi_csis_probe(struct platform_device *pdev)
 			goto e_sd_host;
 	}
 
-	mipi_csis_clk_disable(state);
+	if (!(state->cam_format_change))
+		mipi_csis_clk_disable(state);
 	dev_info(&pdev->dev,
 			"lanes: %d, hs_settle: %d, clk_settle: %d, wclk: %d, freq: %u\n",
 		 state->num_lanes, state->hs_settle, state->clk_settle,
diff --git a/drivers/staging/media/imx/imx8-isi-cap.c b/drivers/staging/media/imx/imx8-isi-cap.c
index b6e5a9cfab6c..80e9b75a1187 100644
--- a/drivers/staging/media/imx/imx8-isi-cap.c
+++ b/drivers/staging/media/imx/imx8-isi-cap.c
@@ -498,6 +498,10 @@ static struct vb2_ops mxc_cap_vb2_qops = {
 	.stop_streaming		= cap_vb2_stop_streaming,
 };
 
+/* To enable ctrls in sensor driver, we need to comment the ISI ctrls */
+
+#ifndef CONFIG_VIDEO_ECAM
+
 /*
  * V4L2 controls handling
  */
@@ -600,6 +604,8 @@ int mxc_isi_ctrls_create(struct mxc_isi_cap_dev *isi_cap)
 	return handler->error;
 }
 
+#endif
+
 void mxc_isi_ctrls_delete(struct mxc_isi_cap_dev *isi_cap)
 {
 	struct mxc_isi_ctrls *ctrls = &isi_cap->ctrls;
@@ -730,6 +736,7 @@ static int mxc_isi_capture_open(struct file *file)
 	struct mxc_isi_cap_dev *isi_cap = video_drvdata(file);
 	struct mxc_isi_dev *mxc_isi = mxc_isi_get_hostdata(isi_cap->pdev);
 	struct device *dev = &isi_cap->pdev->dev;
+	struct v4l2_subdev *sd;
 	int ret = -EBUSY;
 
 	mutex_lock(&isi_cap->lock);
@@ -745,6 +752,10 @@ static int mxc_isi_capture_open(struct file *file)
 		return ret;
 	}
 
+	sd = mxc_get_remote_subdev(&isi_cap->sd, __func__);
+        if (!sd)
+		return -ENODEV;
+
 	mutex_lock(&isi_cap->lock);
 	ret = v4l2_fh_open(file);
 	if (ret) {
@@ -1396,6 +1407,125 @@ static int mxc_isi_cap_enum_frameintervals(struct file *file, void *fh,
 	return 0;
 }
 
+#ifdef CONFIG_VIDEO_ECAM
+static int mxc_vidioc_queryctrl(struct file *file, void *fh,
+					struct v4l2_queryctrl *a)
+{
+	struct mxc_isi_cap_dev *isi_cap = video_drvdata(file);
+	struct v4l2_subdev *sd;
+	sd = mxc_get_remote_subdev(&isi_cap->sd, __func__);
+	if (!sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sd, core, queryctrl, a);
+}
+
+static int mxc_vidioc_query_ext_ctrl(struct file *file, void *fh,
+					struct v4l2_query_ext_ctrl *qec)
+{
+	struct v4l2_queryctrl qc = {
+	.id = qec->id
+	};
+	int ret;
+
+	ret = mxc_vidioc_queryctrl(file, fh, &qc);
+	if (ret)
+	return ret;
+
+	qec->id = qc.id;
+	qec->type = qc.type;
+	strlcpy(qec->name, qc.name, sizeof(qec->name));
+	qec->maximum = qc.maximum;
+	qec->minimum = qc.minimum;
+	qec->step = qc.step;
+	qec->default_value = qc.default_value;
+	qec->flags = qc.flags;
+	qec->elem_size = 4;
+	qec->elems = 1;
+	qec->nr_of_dims = 0;
+	memset(qec->dims, 0, sizeof(qec->dims));
+	memset(qec->reserved, 0, sizeof(qec->reserved));
+
+	return 0;
+}
+
+static int mxc_isi_vidioc_querymenu(struct file *file, void *fh,
+					struct v4l2_querymenu *qm)
+{
+	struct mxc_isi_cap_dev *isi_cap = video_drvdata(file);
+	struct v4l2_subdev *sd;
+
+	sd = mxc_get_remote_subdev(&isi_cap->sd, __func__);
+	if (!sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sd, core, querymenu, qm);
+}
+
+static int mxc_isi_vidioc_g_ctrl(struct file *file, void *fh,
+					struct v4l2_control *a)
+{
+	struct mxc_isi_cap_dev *isi_cap = video_drvdata(file);
+	struct v4l2_subdev *sd;
+
+	sd = mxc_get_remote_subdev(&isi_cap->sd, __func__);
+	if (!sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sd, core, g_ctrl, a);
+}
+
+static int mxc_isi_vidioc_s_ctrl(struct file *file, void *fh,
+					struct v4l2_control *a)
+{
+	struct mxc_isi_cap_dev *isi_cap = video_drvdata(file);
+	struct v4l2_subdev *sd;
+	sd = mxc_get_remote_subdev(&isi_cap->sd, __func__);
+	if (!sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sd, core, s_ctrl, a);
+}
+
+static int mxc_isi_vidioc_g_ext_ctrls(struct file *file, void *fh,
+				  struct v4l2_ext_controls *a)
+{
+	struct mxc_isi_cap_dev *isi_cap = video_drvdata(file);
+	struct v4l2_subdev *sd;
+
+	sd = mxc_get_remote_subdev(&isi_cap->sd, __func__);
+	if (!sd)
+	return -EINVAL;
+
+	return v4l2_subdev_call(sd, core, g_ext_ctrls, a);
+}
+
+static int mxc_isi_vidioc_try_ext_ctrls(struct file *file, void *fh,
+				  struct v4l2_ext_controls *a)
+{
+	struct mxc_isi_cap_dev *isi_cap = video_drvdata(file);
+	struct v4l2_subdev *sd;
+
+	sd = mxc_get_remote_subdev(&isi_cap->sd, __func__);
+	if (!sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sd, core, try_ext_ctrls, a);
+}
+
+static int mxc_isi_vidioc_s_ext_ctrls(struct file *file, void *fh,
+			  struct v4l2_ext_controls *a)
+{
+	struct mxc_isi_cap_dev *isi_cap = video_drvdata(file);
+	struct v4l2_subdev *sd;
+
+	sd = mxc_get_remote_subdev(&isi_cap->sd, __func__);
+	if (!sd)
+		return -EINVAL;
+	return v4l2_subdev_call(sd, core, s_ext_ctrls, a);
+}
+#endif
+
 static const struct v4l2_ioctl_ops mxc_isi_capture_ioctl_ops = {
 	.vidioc_querycap		= mxc_isi_cap_querycap,
 
@@ -1424,8 +1554,21 @@ static const struct v4l2_ioctl_ops mxc_isi_capture_ioctl_ops = {
 	.vidioc_enum_framesizes = mxc_isi_cap_enum_framesizes,
 	.vidioc_enum_frameintervals = mxc_isi_cap_enum_frameintervals,
 
+#ifdef CONFIG_VIDEO_ECAM
+	.vidioc_queryctrl	= mxc_vidioc_queryctrl,
+	.vidioc_query_ext_ctrl	= mxc_vidioc_query_ext_ctrl,
+	.vidioc_querymenu	= mxc_isi_vidioc_querymenu,
+	.vidioc_g_ctrl		= mxc_isi_vidioc_g_ctrl,
+	.vidioc_s_ctrl		= mxc_isi_vidioc_s_ctrl,
+	.vidioc_g_ext_ctrls	= mxc_isi_vidioc_g_ext_ctrls,
+	.vidioc_s_ext_ctrls	= mxc_isi_vidioc_s_ext_ctrls,
+	.vidioc_try_ext_ctrls	= mxc_isi_vidioc_try_ext_ctrls
+#endif
+
+#ifndef CONFIG_VIDEO_ECAM
 	.vidioc_subscribe_event   =  v4l2_ctrl_subscribe_event,
 	.vidioc_unsubscribe_event =  v4l2_event_unsubscribe,
+#endif
 };
 
 /* Capture subdev media entity operations */
@@ -1739,23 +1882,31 @@ static int mxc_isi_register_cap_device(struct mxc_isi_cap_dev *isi_cap,
 	if (ret)
 		goto err_free_ctx;
 
+/* To enable ctrls in sensor driver, we need to comment the ISI ctrls */
+#ifndef CONFIG_VIDEO_ECAM
+
 	ret = mxc_isi_ctrls_create(isi_cap);
 	if (ret)
 		goto err_me_cleanup;
+#endif
 
 	ret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);
 	if (ret)
 		goto err_ctrl_free;
 
+#ifndef CONFIG_VIDEO_ECAM
 	vdev->ctrl_handler = &isi_cap->ctrls.handler;
+#endif
 	v4l2_info(v4l2_dev, "Registered %s as /dev/%s\n",
 		  vdev->name, video_device_node_name(vdev));
 
 	return 0;
 
 err_ctrl_free:
+#ifndef CONFIG_VIDEO_ECAM
 	mxc_isi_ctrls_delete(isi_cap);
 err_me_cleanup:
+#endif
 	media_entity_cleanup(&vdev->entity);
 err_free_ctx:
 	return ret;
@@ -1792,7 +1943,10 @@ static void mxc_isi_subdev_unregistered(struct v4l2_subdev *sd)
 	vdev = &isi_cap->vdev;
 	if (video_is_registered(vdev)) {
 		video_unregister_device(vdev);
+/* To enable ctrls in sensor driver, we need to comment the ISI ctrls*/
+#ifndef CONFIG_VIDEO_ECAM
 		mxc_isi_ctrls_delete(isi_cap);
+#endif
 		media_entity_cleanup(&vdev->entity);
 	}
 	mutex_unlock(&isi_cap->lock);
diff --git a/drivers/staging/media/imx/imx8-isi-fmt.c b/drivers/staging/media/imx/imx8-isi-fmt.c
index db11c809a3d3..7874b163f99b 100644
--- a/drivers/staging/media/imx/imx8-isi-fmt.c
+++ b/drivers/staging/media/imx/imx8-isi-fmt.c
@@ -8,6 +8,15 @@
 
 struct mxc_isi_fmt mxc_isi_out_formats[] = {
 	{
+		.name		= "UYVY-16",
+		.fourcc		= V4L2_PIX_FMT_UYVY,
+		.depth		= { 16 },
+		.color		= MXC_ISI_OUT_FMT_YUV422_1P8P,
+	.memplanes	= 1,
+		.colplanes	= 1,
+		.mbus_code  = MEDIA_BUS_FMT_UYVY8_2X8,
+	}, {
+
 		.name		= "RGB565",
 		.fourcc		= V4L2_PIX_FMT_RGB565,
 		.depth		= { 16 },
@@ -42,7 +51,7 @@ struct mxc_isi_fmt mxc_isi_out_formats[] = {
 		.memplanes	= 1,
 		.colplanes	= 1,
 		.align		= 3,
-		.mbus_code	= MEDIA_BUS_FMT_YUYV8_1X16,
+		.mbus_code	= MEDIA_BUS_FMT_YUYV8_2X8,
 	}, {
 		.name		= "YUV32 (X-Y-U-V)",
 		.fourcc		= V4L2_PIX_FMT_YUV32,
diff --git a/drivers/staging/media/imx/imx8-mipi-csi2-sam.c b/drivers/staging/media/imx/imx8-mipi-csi2-sam.c
index 1d12365520a6..8701978ad4f2 100644
--- a/drivers/staging/media/imx/imx8-mipi-csi2-sam.c
+++ b/drivers/staging/media/imx/imx8-mipi-csi2-sam.c
@@ -1272,6 +1272,144 @@ static int mipi_csis_enum_frameintervals(struct v4l2_subdev *mipi_sd,
 	return v4l2_subdev_call(sen_sd, pad, enum_frame_interval, NULL, fie);
 }
 
+#ifdef CONFIG_VIDEO_ECAM
+
+static int mipi_csis_s_parm(struct v4l2_subdev *mipi_sd, struct v4l2_streamparm *a)
+{
+        struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+        struct v4l2_subdev *sen_sd;
+
+        /* Get remote source pad subdev */
+        sen_sd = csis_get_remote_subdev(state, __func__);
+        if (!sen_sd) {
+                v4l2_err(&state->sd, "%s, No remote subdev found!\n", __func__);
+                return -EINVAL;
+        }
+
+        return v4l2_subdev_call(sen_sd, video, s_parm, a);
+}
+
+static int mipi_csis_g_parm(struct v4l2_subdev *mipi_sd, struct v4l2_streamparm *a)
+{
+        struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+        struct v4l2_subdev *sen_sd;
+
+        /* Get remote source pad subdev */
+        sen_sd = csis_get_remote_subdev(state, __func__);
+        if (!sen_sd) {
+                v4l2_err(&state->sd, "%s, No remote subdev found!\n", __func__);
+                return -EINVAL;
+        }
+
+        return v4l2_subdev_call(sen_sd, video, g_parm, a);
+}
+
+static int mipi_csis_queryctrl(struct v4l2_subdev *mipi_sd, struct v4l2_queryctrl *qc)
+{
+        struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+        struct v4l2_subdev *sen_sd;
+
+        /* Get remote source pad subdev */
+        sen_sd = csis_get_remote_subdev(state, __func__);
+        if (!sen_sd) {
+                v4l2_err(&state->sd, "%s, No remote subdev found!\n", __func__);
+                return -EINVAL;
+        }
+
+	return v4l2_subdev_call(sen_sd, core, queryctrl, qc);
+}
+
+static int mipi_csis_g_ctrl(struct v4l2_subdev *mipi_sd, struct v4l2_control *ctrl)
+{
+        struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+        struct v4l2_subdev *sen_sd;
+
+        /* Get remote source pad subdev */
+        sen_sd = csis_get_remote_subdev(state, __func__);
+        if (!sen_sd) {
+                v4l2_err(&state->sd, "%s, No remote subdev found!\n", __func__);
+                return -EINVAL;
+        }
+
+	return v4l2_subdev_call(sen_sd, core, g_ctrl, ctrl);
+}
+
+static int mipi_csis_s_ctrl(struct v4l2_subdev *mipi_sd, struct v4l2_control *ctrl)
+{
+        struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+        struct v4l2_subdev *sen_sd;
+
+        /* Get remote source pad subdev */
+        sen_sd = csis_get_remote_subdev(state, __func__);
+        if (!sen_sd) {
+                v4l2_err(&state->sd, "%s, No remote subdev found!\n", __func__);
+                return -EINVAL;
+        }
+
+	return v4l2_subdev_call(sen_sd, core, s_ctrl, ctrl);
+}
+
+static int mipi_csis_g_ext_ctrls(struct v4l2_subdev *mipi_sd, struct v4l2_ext_controls *ctrls)
+{
+        struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+        struct v4l2_subdev *sen_sd;
+
+        /* Get remote source pad subdev */
+        sen_sd = csis_get_remote_subdev(state, __func__);
+        if (!sen_sd) {
+                v4l2_err(&state->sd, "%s, No remote subdev found!\n", __func__);
+                return -EINVAL;
+        }
+
+	return v4l2_subdev_call(sen_sd, core, g_ext_ctrls, ctrls);
+}
+
+static int mipi_csis_s_ext_ctrls(struct v4l2_subdev *mipi_sd, struct v4l2_ext_controls *ctrls)
+{
+        struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+        struct v4l2_subdev *sen_sd;
+
+        /* Get remote source pad subdev */
+        sen_sd = csis_get_remote_subdev(state, __func__);
+        if (!sen_sd) {
+                v4l2_err(&state->sd, "%s, No remote subdev found!\n", __func__);
+                return -EINVAL;
+        }
+
+	return v4l2_subdev_call(sen_sd, core, s_ext_ctrls, ctrls);
+}
+
+static int mipi_csis_try_ext_ctrls(struct v4l2_subdev *mipi_sd, struct v4l2_ext_controls *ctrls)
+{
+        struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+        struct v4l2_subdev *sen_sd;
+
+        /* Get remote source pad subdev */
+        sen_sd = csis_get_remote_subdev(state, __func__);
+        if (!sen_sd) {
+                v4l2_err(&state->sd, "%s, No remote subdev found!\n", __func__);
+                return -EINVAL;
+        }
+
+	return v4l2_subdev_call(sen_sd, core, try_ext_ctrls, ctrls);
+}
+
+static int mipi_csis_querymenu(struct v4l2_subdev *mipi_sd, struct v4l2_querymenu *qm)
+{
+        struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+        struct v4l2_subdev *sen_sd;
+
+        /* Get remote source pad subdev */
+        sen_sd = csis_get_remote_subdev(state, __func__);
+        if (!sen_sd) {
+                v4l2_err(&state->sd, "%s, No remote subdev found!\n", __func__);
+                return -EINVAL;
+        }
+
+	return v4l2_subdev_call(sen_sd, core, querymenu, qm);
+}
+#endif
+
 static int mipi_csis_log_status(struct v4l2_subdev *mipi_sd)
 {
 	struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
@@ -1417,12 +1555,25 @@ static struct v4l2_subdev_core_ops mipi_csis_core_ops = {
 	.s_power = mipi_csis_s_power,
 	.log_status = mipi_csis_log_status,
 	.ioctl = csis_priv_ioctl,
+#ifdef CONFIG_VIDEO_ECAM
+	.queryctrl = mipi_csis_queryctrl,
+        .g_ctrl = mipi_csis_g_ctrl,
+        .s_ctrl = mipi_csis_s_ctrl,
+        .g_ext_ctrls = mipi_csis_g_ext_ctrls,
+        .s_ext_ctrls = mipi_csis_s_ext_ctrls,
+        .try_ext_ctrls = mipi_csis_try_ext_ctrls,
+        .querymenu = mipi_csis_querymenu,
+#endif
 };
 
 static struct v4l2_subdev_video_ops mipi_csis_video_ops = {
 	.s_rx_buffer = mipi_csis_s_rx_buffer,
 	.s_stream = mipi_csis_s_stream,
 
+#ifdef CONFIG_VIDEO_ECAM
+        .s_parm = mipi_csis_s_parm,
+        .g_parm = mipi_csis_g_parm,
+#endif
 	.g_frame_interval = mipi_csis_g_frame_interval,
 	.s_frame_interval = mipi_csis_s_frame_interval,
 };
diff --git a/include/media/v4l2-subdev.h b/include/media/v4l2-subdev.h
index f0cc537ea9ef..ce862d1c38e2 100644
--- a/include/media/v4l2-subdev.h
+++ b/include/media/v4l2-subdev.h
@@ -198,6 +198,17 @@ struct v4l2_subdev_core_ops {
 	int (*load_fw)(struct v4l2_subdev *sd);
 	int (*reset)(struct v4l2_subdev *sd, u32 val);
 	int (*s_gpio)(struct v4l2_subdev *sd, u32 val);
+
+#ifdef CONFIG_VIDEO_ECAM
+	int (*queryctrl)(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc);
+	int (*g_ctrl)(struct v4l2_subdev *sd, struct v4l2_control *ctrl);
+	int (*s_ctrl)(struct v4l2_subdev *sd, struct v4l2_control *ctrl);
+	int (*querymenu)(struct v4l2_subdev *sd, struct v4l2_querymenu *qm);
+	int (*g_ext_ctrls)(struct v4l2_subdev *sd, struct v4l2_ext_controls *ctrls);
+	int (*s_ext_ctrls)(struct v4l2_subdev *sd, struct v4l2_ext_controls *ctrls);
+	int (*try_ext_ctrls)(struct v4l2_subdev *sd, struct v4l2_ext_controls *ctrls);
+#endif
+	
 	long (*command)(struct v4l2_subdev *sd, unsigned int cmd, void *arg);
 	long (*ioctl)(struct v4l2_subdev *sd, unsigned int cmd, void *arg);
 #ifdef CONFIG_COMPAT
